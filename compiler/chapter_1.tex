\chapter{加法器}

本章需要处理的语言是一个加法器，该语言记为\textbf{L1}。源码通过词法分析，语法分析，转换为抽象语法树（abstract syntax code,AST）。接着将抽象语法树打平为类似汇编的语言。最后经过栈上空间分配以及修正，得到X84-64汇编。通过gcc编译器，就可以将得到的汇编代码变成可执行文件在机器上运行。

\section{抽象语法树}

下面给出\textbf{L1}语言的一些例子。如下所示，“42”、“(+ 1 2)”、“(+ (+ 1 2) (+ 3 4))”分别是三个不同的程序。它们的运行结果分别为“42”、“3”与“10”。感兴趣的同学可以下载一个lisp环境比如racket来体验一下交互式的操作。

\begin{lstlisting}[%
  language=lisp,
  caption={L1语言样例}
]
# 一个数字是一个合法的程序
42
=> 42
# 加法程序
(+ 1 2)
=> 3
# 嵌套的加法
(+ (+ 1 2) (+ 3 4))
=> 10
\end{lstlisting}


\textbf{L1}语言的语法描述如下。

\begin{equation}
\begin{aligned}
  \label{eq:1}
   Program \quad &::= \quad Exp \\
   Exp \quad &::= \quad (+ \quad Exp \quad Exp) \\
   Exp \quad &::=  \quad Int
\end{aligned}
\end{equation}

第一个规则，说明我们的程序只含有一个表达式Exp，第二个规则表明(+ Exp Exp)是一个表达式，第三个规则表明整数也是一个表达式。在这个定义中，有如下几部分。

\begin{itemize}
  \item \textbf{非终结符}。需要推导成其它组成元素的就是非终结符。非终结符以大写字母开头，比如Exp。
  \item \textbf{终结符}。不能往下推导的元素是终结符.如上例中的+、(、)，或者是以小写字母开头的字符串。
  \item \textbf{产生式}。推导规则就是产生式.产生式的左边一定是一个非终结符,右边是终结符和非终结符组合而成.左右以“::=”分割。
\end{itemize}

上面的语法，可以简写为下面的形式。左部相同的产生式可以缩为一行。用“|”分割,代表“or”，含义是或者。

\begin{equation}
\begin{aligned}
  \label{eq:2}
   Program \quad &::= \quad Exp \\
   Exp \quad &::= \quad (+ \quad Exp \quad Exp) \quad | \quad Int
\end{aligned}
\end{equation}

程序嵌套的语法结构，非常适合用树来进行表示。上述的3段代码其实对应3个树形的结构，见下图的a、b、c。叶子节点对应的是终结符，从父节点到其子节点的关系则对应一个产生式。

\begin{figure}[ht]
\centering
\includegraphics[scale=1]{figs/c1/pic1.png}
\caption{语法树}
\label{fig:fig1}
\end{figure}

本书采用Python中的list来表示这种嵌套的语法。\textbf{L1}语言中的Int直接用Python中的整数进行表示，“+”的操作符用字符串来表示，语法树的嵌套的结构则用嵌套的list进行表示。下面的代码就是a、b、c所对应的Python表示。

\begin{lstlisting}[%
  language=python,
  caption={语法树在python中表示}
]
# 一个数字是一个合法的程序
tree1 = 42
# 加法程序
tree2 = ["+", 1, 2]
# 嵌套的加法
tree3 = ["+", ["+", 1, 2], ["+", 3, 4]]
\end{lstlisting}

下一步，就是将字符串表示的程序，转换成上述的list结构。


\section{scan\&parse}



\begin{lstlisting}[%
  language=python,
  caption={scan\&parse}
]
def scan(code):
    return code.replace("(", " ( ").replace(")", " ) ").split()

def parse(tokens):
    if len(tokens) == 0:
        raise SyntaxError("Meet unexpected EOF")
    token = tokens.pop(0)
    if token == '(':
        exp_lst = []
        while tokens[0] != ')':
            exp_lst.append(parse(tokens))
        tokens.pop(0)    # pop off ')'
        return exp_lst
    elif token == ')':
        raise SyntaxError('unexpected )')
    elif token[0].isdigit():
        return int(token)
    else:
        return token
\end{lstlisting}
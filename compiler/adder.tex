\chapter{加法器}

本章需要处理的语言是一个加法器，该语言记为\textbf{L1}。源码通过词法分析，语法分析，转换为抽象语法树（abstract syntax code,AST）。接着将抽象语法树打平为类似汇编的语言。最后经过栈上空间分配以及修正，得到X84-64汇编。通过gcc编译器，就可以将得到的汇编代码变成可执行文件在机器上运行。

\section{抽象语法树}

下面给出\textbf{L1}语言的一些例子。如下所示，“42”、“(+ 1 2)”、“(+ (+ 1 2) (+ 3 4))”分别是三个不同的程序。它们的运行结果分别为“42”、“3”与“10”。为了解析简单，\textbf{L1}语言采用的是带括号的前缀语法，根据括号中的第一个符号，就可以判断出表达式的类型。

\begin{lstlisting}[%
  language=lisp,
  caption={L1语言样例}
]
# 一个数字是一个合法的程序
42
=> 42
# 加法程序
(+ 1 2)
=> 3
# 嵌套的加法
(+ (+ 1 2) (+ 3 4))
=> 10
\end{lstlisting}


\textbf{L1}语言的语法描述如下。

\begin{equation}
\begin{aligned}
  \label{eq:1}
   Program \quad &::= \quad Exp \\
   Exp \quad &::= \quad (+ \quad Exp \quad Exp) \\
   Exp \quad &::=  \quad Int
\end{aligned}
\end{equation}

第一个规则，说明我们的程序只含有一个表达式Exp，第二个规则表明(+ Exp Exp)是一个表达式，第三个规则表明整数也是一个表达式。在这个定义中，有如下几部分。

\begin{itemize}
  \item \textbf{非终结符}。需要推导成其它组成元素的就是非终结符。非终结符以大写字母开头，比如Exp。
  \item \textbf{终结符}。不能往下推导的元素是终结符.如上例中的+、(、)，或者是以小写字母开头的字符串。
  \item \textbf{产生式}。推导规则就是产生式.产生式的左边一定是一个非终结符,右边是终结符和非终结符组合而成.左右以“::=”分割。
\end{itemize}

上面的语法，可以简写为下面的形式。左部相同的产生式可以缩为一行。用“|”分割,代表“or”，含义是或者。

\begin{equation}
\begin{aligned}
  \label{eq:2}
   Program \quad &::= \quad Exp \\
   Exp \quad &::= \quad (+ \quad Exp \quad Exp) \quad | \quad Int
\end{aligned}
\end{equation}

程序嵌套的语法结构，非常适合用树来进行表示。上述的3段代码其实对应3个树形的结构，见下图的a、b、c。叶子节点对应的是终结符，从父节点到其子节点的关系则对应一个产生式。

\begin{figure}[ht]
\centering
\includegraphics[scale=0.8]{figs/c1/pic1.eps}
\caption{语法树}
\label{fig:fig1}
\end{figure}

本书采用Python中的list来表示这种嵌套的语法。\textbf{L1}语言中的Int直接用Python中的整数进行表示，“+”的操作符用字符串来表示，语法树的嵌套的结构则用嵌套的list进行表示。下面的代码就是a、b、c所对应的Python表示。

\begin{lstlisting}[%
  language=python,
  caption={语法树在python中表示}
]
# 一个数字是一个合法的程序
tree1 = 42
# 加法程序
tree2 = ["+", 1, 2]
# 嵌套的加法
tree3 = ["+", ["+", 1, 2], ["+", 3, 4]]
\end{lstlisting}

现在的问题，就是要将字符串表示的程序，转换成上述的list结构。


\section{scan\&parse}

经过观察，可以发现\textbf{L1}语言中的元素，除了“(”“)”，其它大部分都是按照空格分开的。可以将括号左右都添加上空格，然后按照空格切分，就可以将代码中的每个元素都装到一个list中。“(+ (+ 1 2) (+ 3 4))”通过scan函数，就会转换为["(", "+", "(", "+", "1", "2", ")", "(", "+", "3", "4", ")", ")"]。列表中的每个元素，都是一个token。这一步，就是一个简单的词法分析过程，将源码转换为token的列表。

\begin{lstlisting}[%
  language=python,
  caption={scan\&parse}
]
def scan(code):
    return code.replace("(", " ( ").replace(")", " ) ").split()

def parse(tokens):
    if len(tokens) == 0:
        raise SyntaxError("Parse Err: Unexpected EOF")
    token = tokens.pop(0)
    if token == '(':
        exp_lst = []
        while tokens[0] != ')':
            exp_lst.append(parse(tokens))
        tokens.pop(0)    # pop off ')'
        return exp_lst
    elif token == ')':
        raise SyntaxError('Parse Err: Unexpected )')
    elif token[0].isdigit() or token[0] == "-":
        return int(token)
    else:
        return token
\end{lstlisting}

接下来，采用递归下降的方式，将token列表转换为语法树。每次从token列表中取第一个token。
\begin{itemize}
  \item 读到“(”，说明需要新建一个列表。递归的调用parse函数，将解析出的表达式exp放入新的列表中，直到读到“)”为止。
  \item 读到“）”，不符合语法，抛出异常。
  \item token的第一个字符是数字或者减号，说明读到一个数字，将其从字符串转换为整数返回。
  \item 其它情况，就是读到标识符。以字符串形式返回即可。
\end{itemize}

经过parse函数处理，就会将上述的token列表转换为["+", ["+", 1, 2], ["+", 3, 4]]，嵌套的结构正好对应语法树。这一步，就是一个简单的语法分析过程，将token列表解析为语法树，为后续的处理打下基础。

\section{语法树打平}

汇编语言是平铺的语言，并无树形的代码结构。因此需要将语法树按照执行的顺序进行打平。打平后的相当于是一个更加接近于汇编语法的语言。打平后的语法如下，记为\textbf{Flat}语言。

\begin{equation}
\begin{aligned}
  \label{eq:3}
   Program \quad &::= \quad {AssignExp}^* \quad ReturnExp \\
   AssignExp \quad &::= \quad (assign \quad Var \quad (+ \quad SimpleExp \quad SimpleExp)) \\
   ReturnExp \quad &::= \quad (return \quad SimpleExp) \\
   SimpleExp \quad &::=  \quad Int \quad | \quad Var
\end{aligned}
\end{equation}

实际处理起来，相当于对\textbf{L1}语言的语法树进行了一次深度优先遍历。在遍历过程中，每次遇到“+”节点，按照遍历的顺序，就会产生一个临时变量，这里使用一个符号词典Symbols.symbol\_dict来记录所有的变量及目前对应的序号,初始序号记为1。按顺次调用Symbols.get\_new\_symbol("tmp")，就会依次产出“tmp.1”、“tmp.2”、“tmp.3”…。

\begin{figure}[ht]
\centering
\includegraphics[scale=0.8]{figs/c1/pic2.eps}
\caption{深度优先遍历产生临时变量}
\label{fig:fig2}
\end{figure}


\begin{lstlisting}[%
  language=python,
  caption={flatten}
]
class Symbols:
    symbol_dict = {}
    @staticmethod
    def get_new_symbol(var):
        if var not in Symbols.symbol_dict:
            Symbols.symbol_dict[var] = 1
        else:
            Symbols.symbol_dict[var] += 1
        return var + "." + str(Symbols.symbol_dict[var])

class Flatten:
    def __init__(self, exp):
        self.exp = exp
        self.op_lst = []
    
    def flatten(self, exp):
        exp_type = type(exp)
        if exp_type in (int, str):
            return exp
        elif exp_type == list:
            if exp[0] == "+":
                exp1 = self.flatten(exp[1])
                exp2 = self.flatten(exp[2])
                tmp_var = Symbols.get_new_symbol("tmp")
                self.op_lst.append(("assign", tmp_var, ("+", exp1, exp2)))
                return tmp_var
        raise SyntaxError('Flatten Err: Unkown Exp {}'.format(exp))

    def run(self):
        final_exp = self.flatten(self.exp)
        self.op_lst.append(("return", final_exp))
\end{lstlisting}

Flatten构造时传入一棵语法树，通过run函数来开始执行，使用op\_lst来记录在遍历语法树的过程中产生的操作。

其中flatten函数根据输入的表达式，将其转换为int或者是一个变量进行返回。
\begin{itemize}
  \item 如果输入的是变量或int，直接返回。
  \item 如果是加法表达式，先递归的处理左子树和右子树，得到它们的处理结果exp1和exp2。然后Symbols中获取一个全新的tmp变量，将其与exp1、exp2产生一个新的assign操作。最后返回新生成的这个tmp变量。
\end{itemize}

最后，将整个表达式flatten之后的结果，拼装一个return语句即可。

\begin{lstlisting}[%
  language=python,
  caption={Flatten结果}
]
# 语法树
['+', ['+', 1, 2], ['+', 3, 4]]
# [Flatten] 后的结果
('assign', 'tmp.1', ('+', 1, 2))
('assign', 'tmp.2', ('+', 3, 4))
('assign', 'tmp.3', ('+', 'tmp.1', 'tmp.2'))
('return', 'tmp.3')
\end{lstlisting}

\section{选择合适x86代码}

\textbf{Flat}语言是一个平整的语言，与汇编代码只有些微的差别。但将其直接转变为汇编仍有些不好处理，因此引入一个扩展的x86语言，\textbf{x86-E}语言。\textbf{x86-E}语言仍然保留变量的设定，同时引入寄存器的概念。

\begin{equation}
\begin{aligned}
  \label{eq:4}
   Program \quad &::= \quad { MovOrAddExp }^* \\
   MovOrAddExp \quad &::= \quad \{ movq \quad | \quad addq \} \quad S \quad  D  \\
   S \quad &::= \quad Reg \quad | \quad Var \quad | \quad Int \\
   D \quad &::=  \quad Reg \quad | \quad Var
\end{aligned}
\end{equation}

\begin{lstlisting}[%
  language=python,
  caption={select\_instruction}
]
def mark_val(val):
    if type(val) == int:
        return "int", val
    else:
        return "var", val

def select_instruction(op_lst):
    new_op_lst = []
    for inst in op_lst:
        if inst[0] == "assign":
            var = inst[1]
            add_exp = inst[2]
            add_exp1 = add_exp[1]
            add_exp2 = add_exp[2]
            new_op_lst.append(("movq", mark_val(add_exp1), ("var", var)))
            new_op_lst.append(("addq", mark_val(add_exp2), ("var", var)))
        elif inst[0] == "return":
            new_op_lst.append(("movq", mark_val(inst[1]), ("reg", "rax")))
    return new_op_lst
\end{lstlisting}

\begin{lstlisting}[%
  language=python,
  caption={select\_instruction结果}
]
('movq', ('int', 1), ('var', 'tmp.1'))
('addq', ('int', 2), ('var', 'tmp.1'))
('movq', ('int', 3), ('var', 'tmp.2'))
('addq', ('int', 4), ('var', 'tmp.2'))
('movq', ('var', 'tmp.1'), ('var', 'tmp.3'))
('addq', ('var', 'tmp.2'), ('var', 'tmp.3'))
('movq', ('var', 'tmp.3'), ('reg', 'rax'))
\end{lstlisting}

\section{分配栈上空间}

\begin{lstlisting}[%
  language=python,
  caption={assign\_home}
]
class StackFrame:
    symbol_pos_dict = {}
    frame_size = 0

def get_var_pos(arg):
    if arg[0] == "var":
        return ("deref", "rbp", StackFrame.symbol_pos_dict[arg[1]])
    else:
        return arg

def assign_home(op_lst):
    base = 0
    for var, count in Symbols.symbol_dict.items():
        StackFrame.frame_size += 8 * count
        for i in range(count):
            base = base - 8
            StackFrame.symbol_pos_dict[var + "." + str(i+1)] = base
    if StackFrame.frame_size % 16 != 0:
        StackFrame.frame_size += 8
    new_op_lst = []
    for inst in op_lst:
        new_op_lst.append((inst[0], 
                            get_var_pos(inst[1]), 
                            get_var_pos(inst[2])))
    return new_op_lst
\end{lstlisting}

\begin{lstlisting}[%
  language=python,
  caption={assign\_home结果}
]
('movq', ('int', 1), ('deref', 'rbp', -8))
('addq', ('int', 2), ('deref', 'rbp', -8))
('movq', ('int', 3), ('deref', 'rbp', -16))
('addq', ('int', 4), ('deref', 'rbp', -16))
('movq', ('deref', 'rbp', -8), ('deref', 'rbp', -24))
('addq', ('deref', 'rbp', -16), ('deref', 'rbp', -24))
('movq', ('deref', 'rbp', -24), ('reg', 'rax'))
\end{lstlisting}

\section{代码修正}

\begin{lstlisting}[%
  language=python,
  caption={patch\_instuction}
]
def patch_instuction(op_lst):
    new_op_lst = []
    for inst in op_lst:
        arg1 = inst[1]
        arg2 = inst[2]
        if arg1[0] == "deref" and arg2[0] == "deref":
            new_op_lst.append(("movq", arg1, ("reg", "rax")))
            new_op_lst.append((inst[0], ("reg", "rax"), arg2))
        else:
            new_op_lst.append(inst)
    return new_op_lst
\end{lstlisting}

\begin{lstlisting}[%
  language=python,
  caption={patch结果}
]
('movq', ('int', 1), ('deref', 'rbp', -8))
('addq', ('int', 2), ('deref', 'rbp', -8))
('movq', ('int', 3), ('deref', 'rbp', -16))
('addq', ('int', 4), ('deref', 'rbp', -16))
('movq', ('deref', 'rbp', -8), ('reg', 'rax'))
('movq', ('reg', 'rax'), ('deref', 'rbp', -24))
('movq', ('deref', 'rbp', -16), ('reg', 'rax'))
('addq', ('reg', 'rax'), ('deref', 'rbp', -24))
('movq', ('deref', 'rbp', -24), ('reg', 'rax'))
\end{lstlisting}

\section{产出汇编代码}

\begin{lstlisting}[%
  language=python,
  caption={print\_x84\_64}
]
def trans_operand_to_str(operand):
    if operand[0] == "int":
        return "$" + str(operand[1])
    elif operand[0] == "deref":
        return str(operand[2]) + "(%" + operand[1] + ")"
    elif operand[0] == "reg":
        return "%" + operand[1]

def print_x84_64(op_lst):
    print("    .global main")
    print("main:")
    print("    pushq %rbp")
    print("    movq %rsp, %rbp")
    print("    subq $" + str(StackFrame.frame_size) + ", %rsp")
    for inst in op_lst:
        print("    " + inst[0] + " " + trans_operand_to_str(inst[1]) + ", " + trans_operand_to_str(inst[2]))
    print("    addq $" + str(StackFrame.frame_size) + ", %rsp")
    print("    popq %rbp")
    print("    retq")
\end{lstlisting}

\begin{lstlisting}[%
  language=python,
  caption={最终产出}
]
    .global main
main:
    pushq %rbp
    movq %rsp, %rbp
    subq $32, %rsp
    movq $1, -8(%rbp)
    addq $2, -8(%rbp)
    movq $3, -16(%rbp)
    addq $4, -16(%rbp)
    movq -8(%rbp), %rax
    movq %rax, -24(%rbp)
    movq -16(%rbp), %rax
    addq %rax, -24(%rbp)
    movq -24(%rbp), %rax
    addq $32, %rsp
    popq %rbp
    retq
\end{lstlisting}


\begin{lstlisting}[language=bash,style=shellstyle]
  gcc -o add add.s
  ./add
  echo $?
\end{lstlisting}

\section{小结}
